## Incident Overview

- A report with a valid vulnerability was submitted for `yBOLD` through Immunefi
- The vulnerability could cause the yield not to flow as intended to `ysyBOLD`
- Exploitation would only have been possible under specific conditions: (1) the underlying strategy would need to accrue losses and (2) those losses would need to be manually accepted by the strategy management (which is blocked by default via `healthCheck`)
- A fix was developed, reviewed, and deployed to production

## Background

`yBOLD` is designed to always keep its price-per-share (`PPS`) ratio at `1`.

- All profit which would otherwise lead to `PPS > 1` is forwarded to `ysyBOLD` as rewards
- In the event of losses (`PPS < 1`), no rewards are earned until the vault recovers and `PPS == 1`

This is achieved via a custom `Accountant` contract, which:
1. Hardcodes performance fee to 100% so they can be redirected to `ysyBOLD`
2. Only applies fees if there are no outstanding losses

## Vulnerability Details

The calculation of losses in the `Accountant` contract was flawed. Specifically, it determined losses as:

```
// Only take fee if there's no loss.
uint256 supply = vault.totalSupply();
uint256 assets = vault.totalAssets();
if (assets < supply) {
    uint256 needed = supply - assets;
    totalFees = gain < needed ? 0 : gain - needed;
}
```

Here, `supply - assets` is treated as the “loss to be recovered”. However, because deposits increase `totalSupply`, new deposits artificially increase the apparent size of the loss.

#### Example scenario:

Initial state:
	•	`PPS = 0.9` (vault has accrued losses)
	•	`totalAssets = 90`, `totalSupply = 100`
	•	`needed = 10` (correctly reflects losses)

If a user deposits `90` assets at this point (`PPS = 0.9`):
	• `totalAssets = 180`, `totalSupply = 200`
	• `needed = 20`

Now, the vault believes it requires `20` units of profit to restore `PPS` to `1`, even though only `10` units are actually needed. This condition could be repeated indefinitely, preventing the vault from ever recognizing recovery and thus preventing rewards from being paid to `ysyBOLD`.

## Potential Impact

Conditions required for exploitation:
1.	The strategy must first accrue losses. Under normal operation, the strategy uses `healthCheck` to prevent realizing losses on harvests. Manual intervention would be required by strategy management to bypass this safeguard
2.	An attacker could then continuously deposit while `PPS < 1` to inflate the loss metric and block rewards indefinitely

What could not happen:
- No user funds were at risk of theft or permanent loss
- Exploitation could not occur without explicit manual acceptance of losses in the strategy
- Normal operations (where losses are not realized) could never trigger the bug

Practical outcome if exploited:
- Rewards to `ysyBOLD` would be delayed or blocked, reducing expected yield distribution

## Fix Implemented

A `DepositLimitModule` was added to the `yBOLD` vault:
- When the vault is in a loss state (`PPS < 1`), new deposits are blocked
- This ensures deposits cannot artificially increase the needed recovery amount
- Once `PPS` is restored to `1`, deposits resume normally

## Yearn Response Timeline

1. **Immunefi Report** (13 August, ~15:00 UTC)
2. **Initial Assessment** (13 August ~20:30-21:30 UTC)
3. **PR with fix submitted for internal review** (14 August ~21:30 UTC)
4. **Fix deployed to production** (24 August ~18:30 UTC)
5. **[Bounty awarded](https://etherscan.io/tx/0x863d4e774b532c46146114c00ff0f4316318bc12010fd5983af0f0aa0db0fb18) to [whitehat](https://x.com/armormadeofwoe?s=21)** (03 September ~16:40 UTC)

## Lessons Learned

- **More scenario testing**: This vulnerability arose from a subtle interaction between deposits and loss accounting. Our test suite did not cover the case where new deposits are made while `PPS < 1`. Expanding scenario coverage to explicitly test for “loss state + deposits/withdrawals” would have caught this earlier
- **Sanity checks worked as intended**: The `healthCheck` mechanism prevented realized losses in normal operation, meaning the vulnerability was never exploitable in practice. Perhaps more sanity checks should be implemented in our contracts

## References

- [yBOLD contract](https://etherscan.io/address/0x9F4330700a36B29952869fac9b33f45EEdd8A3d8)
- [Custom accountant contract](https://etherscan.io/address/0x53acEBB9470Cfc9D231075154f5dcF1586A4c6fa)
- [Custom accountant code](https://github.com/yearn/yBOLD/blob/6f034c4755520292279a6206e0379b52f4a462dd/src/periphery/Accountant.sol#L179-L185)
- [Yearn V3 code](https://github.com/yearn/yearn-vaults-v3/blob/104a2b233bc6d43ba40720d68355b04d2dc31795/contracts/VaultV3.vy#L1178-L1179)
- [PR with fix](https://github.com/yearn/yBOLD/pull/4)
- [Deployed fix](https://etherscan.io/tx/0x9d61824910042d1ea9932836133b648d05ab26fbdf558770cd672a1ccc3d76a8)
- [DepositLimitModule contract](https://etherscan.io/address/0x746C238E34a6dBFE1d35d50471467Bd7Bf898f62)
